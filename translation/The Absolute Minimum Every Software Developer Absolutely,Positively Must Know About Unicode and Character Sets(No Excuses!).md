origin artical address : https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/



## 所有的软件开发者绝对、肯定、必须知道的Unicode和字符集的编码知识（没有借口！）

​	你有想过HTML标签 Content-Type是什么意思吗？就是那个你知道你应该放在HTML里，但是从来不知道为什么的。

​	你有收到过来自保加利亚（随便一个非拉丁语系）的朋友发来的邮件，然后邮件主题是“???? ???? ???”吗？

​	我很失望的发现，竟然有那么多软件开发者不了解神秘的字符集、编码、Unicode之类的这样一个世界。数年前，一个测试工程师想知道他们的产品能不能处理日文的邮件。日文？他们有邮件是日文的？我没有主意。当我仔细研究我们用于解析MIME邮件信息的商用ActiveX控件时，我们发现它对于字符集的处理完全是错的，因此我们不得不去写海量的代码去把错误的字符转换纠正。当我研究另一个商用字典库时，我发现它也一样，使用了支离破碎、完全错误的字符代码实现。我和这个库的开发者联系了，但是他们的想法是“对此无能为力”。就像许多程序员一样，他只希望这个问题某一天会突然消失。

​	但它不会。当我发现著名的web开发工具PHP几乎完全忽视了字符编码问题，无忧无虑的使用8比特编码，这使得它几乎不可能去开发全球性的应用。我觉得，这一切都够了。

​	所以我在这有一个宣言：如果你是工作在2003年的程序员并且你不知道字符、字符集、编码、Unicode之类的东西，并且被我抓到了，我会把你放到潜水艇里去剥六个月的洋葱。我发誓我会的。

​	还有另一个要强调的：	**这其实并不困难**

​	在这篇文章中，每一个正在工作的程序员到底需要知道什么，我会告诉你。如果你认为只是“纯文本==ascii==八比特字符"，那不仅仅是错了，那是无可救药的错了。并且如果你依旧在以这种方式写代码，你比那些不相信基因的医学博士好不了多少。拜托了，在你看完这篇文章之前，不要再写下一行新的代码了。

​	开始之前，我需要提醒你，如果你是那些少数的知道国际化的人，你会发现我的整个论述有点太简单了。我只是想尽可能的降低门槛，让每一个人都能理解字符转换后面发生了什么，并且根据这些知识可以在包含26个字母之外的字符的语言环境下工作。而且还有一点，那就是字符处理仅仅是开发国际化软件中的小小一部分，但是因为我一次只能讲一件事，所以今天讲字符集。

#### 	历史层面

​	去理解字符这件事最简单的方法就是跟着历史走。

​	你可能会认为我会从很老的字符集像EBCDIC开始讲起，但我不会。EBCDIC与目前关系已经不大了，我们没有必要走那么远。

​	回到一半远的以前，那时UNIX刚被发明，K&R写了《C程序设计语言》，一切都很简单。EBCDIC正在退出历史舞台。那时唯一要考虑的字符就是比较老的非发音英语字符，而且我们可以用ASCII码表示他们。ASCII能够用数字表示所有字符，从32-127。例如空格是32，大写字母A是65。这很方便的存在七比特位里。目前大多数计算机都用8比特代表一字节，因此不仅仅是可以存那些ASCII字符，你还有整整一位去备用。如果你比较顽皮，你可以用它来实现一些你的奇怪的目的：字星程序就使用最高位去表示一个单词里的最后一个字母，我谴责这种只处理英文文本的行为。32以下的叫做非打印字符，一般用于骂人。开个玩笑。它们被用于控制字符，就像7会使计算机鸣叫（蜂鸣器），12会跳过当前页打印下一页。

​	如果你是个英语母语者，这一切都看起来非常美好。

​	因为字节有八位，很多人会想”天哪，我们可以用128-255这些代码做我们自己的事情。“问题在于，同时有很多人有这种想法，并且他们用他们自己的方式决定128-255代表什么。IBM-PC有知名的OEM字符集，使用这一部分字符去代表有发音的欧洲字符和一堆划线字符……水平线，垂直线，旁边有些奇奇怪怪东西的水平线等等。并且你目前仍然可以在8088上跑这些东西，用这些字符画一些干净的盒子和线。事实上，当美国之外的人开始购买PC时，各种各样的OEM字符就开始出现了，都是使用最上面128个字符用于各自的目的。例如，某些电脑里130代表é，但是在以色列的电脑上这代表希伯来语的字母Gimel(λ)，所以当美国人发送信息résumés给以色列人时，他们会收到rλsumλs。在某些情况下，比如俄语，他们有许多不同的关于最上面128个字符的想法，所以你甚至不能可靠的与别人交换俄语文档。

​	最终ANSI标准为这个免费的OEM制定了规则。在ANSI标准中，低128个的用途是一致的，基本上就是ASCII码，但上面128个字符有多种多样的方式去处理，这取决于你所在的国家和地区。这些不同的系统叫做代码页。例如以色列DOS使用862代码页，希腊用户使用737代码页。它们的低128个字符相同但是高128个不同，高128就是奇奇怪怪的字符所在地。国家版本的MS-DOS有着各种各样的代码页，处理着各种语言从英语到冰岛语，并且它们甚至还有可以在一台电脑上同时处理世界语和卡加利西亚语的多语言代码页！哇哦！但还是得说，你不可能在同一台电脑上同时处理希伯来语和希腊语，除非你自己写一个能进行映射的通用软件，因为希伯来语和希腊语使用不同的代码页，这意味着他们对于高128个字符有着不同的解释。

​	同时，在亚洲，我们要考虑更加疯狂的事实，那就是亚洲文字有数以千计的文字，是永远也不可能塞得进8位里的。这通常用一种叫DBCS的杂乱无章的系统解决，就是一种一些字符使用一个字节表示，另一些使用两个字节表示的”双字节字符集“。在这种情况下，字符串往前移动是容易的，但是往后移动几乎是不可能的事情。他们希望程序员不要使用s++和s-去移前后移动下标，而是使用类似Windows提供的AnsiNext和AnsiPrev的函数去做这种事情，这两个函数就是专门用来处理这种混乱的情况的。

​	但依旧有着大量的人认为一个字节代表一个字符并且一个字符占用8位并且只要你不把一个字符串移动到另一台电脑上或者说一种以上的语言，这个字符串就永远可以使用。但是显而易见，随着互联网的出现，把一个字符串从一台电脑移动到另一台电脑是司空见惯的事情，并且上述混乱的局面会变得更加混乱。幸运的是，Unicode出现了。

​	unicode是一个勇敢的尝试，它试图创建一个单一字符集用以包含地球上所有合理的文字系统，包括一些刻意制造的语言例如克林贡语（星际迷航里一个种族的语言）。很多人都这样误解Unicode，认为它只用16bit然后可以表示65536个可能的字符。这并不那么正确。这是Unicode最常见的误区，如果你那么想了，不要觉得不开心。

​	事实上，Unicode考虑字符的方式不太一样，你必须去理解Unicode方法，否则编码就说不通了。

​	到目前为止，我们都假定一个字母与一些比特位相映射因此你可以把它们存在磁盘或内存中：A  --> 0100 0001

​	但是在Unicode里，一个字母与一个叫码点的东西相对应，而码点目前只是个理论概念。码点怎么在内存或磁盘中表示是另一个事情了。

​	在Unicode中，字母A是一个理想的样子。它只在天堂出现：A。这个理想字母A与B不一样，也与a不一样，但是和**A** and ***A*** and *A*是一样的。一般来说，认为新罗马字体的A和海维提卡字体A是同一个字符，而与小写ａ不是一个字符并不会引起争论，但是在有些语言里，仅仅是搞清楚字母是什么含义就足够令人头疼了。德国字母β是一个实际的字符还是说是一种独特的ss的写法？如果一个字母的样子在单词的最后改变了样子，那应该被认为是一个不同的字母吗？犹太人认为是的，阿拉伯人反对。无论如何，Unicode组织里的聪明人已经指出了这件事情有差不多十年时间，并在此之间伴随着不同党派的争吵。但是你不用担心，他们目前已经搞清楚了。

​	每一个字符集的理想字母都被Unicode组织的人赋予了一个魔数，就像这样：U+0639．这种魔数又叫码点。U意味着Unicode，数字是十六进制的。U+0639表示阿拉伯字母Ain。英语A用U+0041表示。你可以用charmap工具（在windows上）或者访问unicode[网站](http://www.unicode.org/)

​	
