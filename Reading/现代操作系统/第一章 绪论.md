个人答案，有错误欢迎联系指正，写有*号的都是以后会再回头看的、进一步琢磨的题目，要么知识点不足，要么回答的感觉不是很好。

##### 1.什么是多道程序设计

​	在内存中放若干不同的作业，当一个作业因I/O问题阻塞时，另一个作业可以使用CPU，从而提高CPU利用率

##### *2.什么是SPOOLing？读者是否认为将来的高级个人计算机会把SPOOLing作为标准功能？

​	SPOOLing全称同时的外部设备联机操作（Simultaneous Peripheral Operation On Line），也称假脱机。意思是通过一个高速的字符设备模拟其它字符设备，如打印机、磁盘等，实现加快输入输出的功能。

​	（官方答案）

> Input spooling is the technique of reading in jobs, for example, from cards,onto the disk, so that when the currently executing processes are finished,there will be work waiting for the CPU. Output spooling consists of first copying printable files to disk before printing them, rather than printing directly as the output is generated. Input spooling on a personal computer is not very likely, but output spooling is.

​	spooling分输入输出。输入spooling是一项读任务的技术，例如从卡带上读取信息到磁盘上，这能让CPU在完成一项任务后立刻开展下一项任务。输出spooling会先将可打印内容复制到磁盘上，然后再打印，而不是直接打印内容。输入spooling在个人计算机上不是很常见，输出spooling很多。

（SPOOLing包含输入输出井balabala，看不太懂，就这样吧）

##### 3.在早期计算机中，每个字节的读写直接由CPU处理（即没有DMA）。对于多道程序而言这种组织方式有什么含义？

​	DMA（Direct Memory Access，直接存储期访问），是有一个专门的DMA控制器控制IO，当IO完成后向CPU发出中断指令。DMA的作用就是将慢速的IO设备独立运行，以提高CPU利用率。如果没有DMA的话，CPU直接控制IO，无法在等待IO完成的时间切换到其它进程进行工作，会极大的降低CPU使用率。

##### 4.系列计算机的思想在20世纪60年代由IBM引入进System/360大型机。现在这种思想已经消亡了还是继续活跃着？

​	继续活跃着，但是并不如System/360那样苛刻，要求兼容所有以往的产品。如当下Intel的指令集，均是兼容以前80386、486、32位机时代的指令并且在此之上扩展的，寄存器的命名从ax,eax,rax，一步步从16位、32位到64位。兼容依旧是吸引力十足的特性。

##### 5.缓慢采用GUI的一个原因是支持它的硬件的成本（高昂）。为了支持25行80列字符的单色文本屏幕应该需要多少视频RAM？对于1024 x 768像素24位色彩位图需要多少视频RAM？在1980年（$5/KB）这些RAM的成本是多少？现在它的成本是多少？

​	第一个问题，25行80列，每个字符是ascii码，占用1B，单色可以当作不考虑大小，即25 * 80 * 1B = 2000B = 2KB

​	第二个问题，1024 x 768像素，24位色彩，单个色彩需要3B，即1024 * 768 * 3B = 2304KB

​	第三个问题，1980年单色文本需要大概10$，而GUI需要11520$！

​	第四个问题，目前(2021年)，8G，DDR4 2666HZ的内存条大概价格在300元，37.5元/GB，大概也就相当于$5/GB，数量级高了六个，此时二者价格差基本可以忽略不计。

##### *6.在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等。请列举两个可能相互矛盾的设计目的。

​	资源利用：提高已有硬件的使用效率，尤其以满足高速设备为主要目的，优先提高CPU、GPU等高速设备的利用率。

​	及时性：对于一个任务能够及时的接受和处理。

​	健壮性：操作系统运行过程有一定的稳定性，不会或较少因为某些外部原因导致系统崩溃。

​	资源利用和健壮性有一定的矛盾：为了提高资源利用率，当某个进程进行IO请求时，CPU会保存上下文然后进行进程切换。但是进程切换这件事情本身就容易出错，尤其是多核下的进程切换、或者进程内有若干线程、多进程协调工作之类的场景，满足健壮性最简单的做法就是不进行进程切换，一个进程从开始到结束运行完毕切换下一个……

​	资源利用和及时性有一定的矛盾：由于需要对于突发事件处理，操作系统必定有一个daemon进程位于后台，在操作系统接受到某个信号后，保存当前进程上下文并且唤醒该后台进程进行事务处理。但是上下文切换本身必定有时延，无非是进程的内容多少带来的上下文切换开销是大是小罢了。更可怕的情况是一个占用内存极大的进程正在运行，会不断发生页面中断，以致于把daemon所需的部分内存页也切换掉，导致daemon运行时会不得不再从磁盘读取内容，开销就更大了。

##### 7.下面的哪一条指令只能在内核态中使用？a)禁止所有的中断。b)读日期-时间时钟。c)设置日期-时间时钟。d)改变存储器映像。

​	a)中断处理是在内核态中完成的。相应的，禁止所有的中断，也就是让CPU对中断信号不做出响应，应该也是只能在内核态进行。

​	b)以1.3.2节的内容而言，时间和日期是保存在CMOS存储期上的，是一种易失性存储器。Linux提供一个系统调用叫time，用于获取系统时间。

​	c)Linux系统调用有一个settimeofday，用于设置日期-时间，系统调用自然需要进入内核态。

​	d)存储器映像（是个啥=。=）应该是修改类似于文件系统的东西，只能在内核态执行。

##### 8.考虑一个有两个CPU的系统，并且每个CPU有两个线程（超线程）。假设有三个程序P0,P1,P2，分别以运行时间5ms,10ms,20ms开始。运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻塞，并且一旦设定就不改变CPU。

​	依调度方式的不同而决定运行时间。四种情况，三个程序均在同一CPU运行，或者其中一个在另一个CPU运行。

​	前者，由于超线程只是在纳秒级切换，并不是真正的并行（1.3.1 处理器--多线程和多核芯片)，因而运行时间相加为35ms;

​	后者，P0单独运行，合计时间需要30ms；P1单独运行，合计时间需要25ms；P2单独运行，合计时间需要20ms。

##### 9.一台机器有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns。这台机器每秒可执行多少条指令？

​	第1ns，第一个流水线单元运行完毕；……；第一条指令运行完毕为第4ns，后面每一ns执行一条指令，大概为10^9-3条。

##### 10.假设一个计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要2ns, RAM需要10ns, 磁盘需要10ms。如果缓存命中率是95%， 内存的是99%（缓存失效时），读取一个词的平均时间是多少？

​	
$$
2ns * \%95 + (1-\%95)(10ns * \%99 + 10ms *(1-\%99))
$$
​	缓存命中时是2ns，不命中时，99%概率在内存中，10ns，不在内存中去读磁盘，10ms

​	结果大约为5us

##### 11.一位校对人员注意到在一部将要出版的操作系统教科书手稿中有一个多次出现的拼写错误。这本书大致有700页。每页50行，一行80个字符。若把文稿用电子扫描，那么，主副本进入图1-9中的每个存储系统的层次要花费多少时间？对于内存储方式，考虑所给定的存取时间是每次一个字符，对于磁盘设备，假定存取时间是每次一个1024字符的盘块，而对于磁带，假设给定开始时间后的存取时间和磁盘存取时间相同。

​	这本书的大小为700 * 50 * 80 * 1B=2,800,000B

​	存储器层次由高到低为寄存器、高速缓存、内存、磁盘、磁带。按我理解的题目意思，内存及以上的设备视为内存储方式，读取数据时每次一个字节。

​	存储器由高到低访问时间，寄存器1ns 高速缓存2ns 内存10ns 磁盘10ms 磁带100s

​	可见内存与磁盘就差了六个数量级，因此一个按字节读入一个按块读入也是非常合理的。

​	寄存器时间：2,800,000/1 * 1ns = 2,800,000ns=2.8ms;

​	高速缓存时间：5.6ms；内存时间：28ms；

​	磁盘时间：2,800,000/1024 * 10ms = 28000ms=28s；

​	磁带时间：100 * 100 * 磁盘时间 = 280000s

##### 12.在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件，一个指向数据缓冲区的指针以及计数。然后，控制权转交给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要把调用者阻塞一直等到磁盘传送完成为止吗？

​	不需要，因为从磁盘读入数据是需要对数据进行处理，没有数据程序当然要被阻塞。而写入的数据已经与调用者无关，已经写入数据缓冲区了，在这种情况下调用者可以继续运行。

##### 13.什么是陷阱指令？在操作系统中解释它的用途。

​	~~书本P28页。陷阱指令是用于从用户态切换到内核态的指令。在操作系统中，应用程序通过操作系统提供的trap指令进入到内核态，从而具有使用一些特殊内核功能的权限，例如访问文件系统、创建进程等。~~

​	书本P12页。TRAP指令把用户态切换成内核态，并启用操作系统。在操作系统中，使用trap指令进入内核态，进行系统调用或者中断处理。

##### 14.陷阱和中断的主要差别是什么？

​	~~陷阱是应用程序主动的行为，行为产生的原因是具体的，结果也应该是可控的，陷阱的发生是有预期的。~~

​	陷阱常见的原因是硬件错误，如电压不稳、试图除零、浮点数溢出、IO设备故障等。

​	中断是指运行过程中，遇到意外情况，CPU需要暂停正在运行的工作，转而处理意外情况的行为。

​	陷阱往往是正在运行的指令出错造成的，而中断往往是指令以外的内容传入的信号中断。

##### 15.在分时系统中为什么需要进程表？在只有一个进程存在的个人计算机系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？

​	因为分时系统下，不同的用户按照时间片或其他进程调度算法轮流使用CPU，在这种情况下，一个进程未完成任务但仍需要保存自己的运行状态，因而需要进程表保存该进程的信息，从而方便下次继续进行。

​	~~我觉得是需要的。即使是单用户单进程操作系统，也会发生中断或者发生其它意外。在这种情况下，如果有进程表，缓慢断电的CPU就可以保存进程信息，从而避免信息丢失。~~

​	It is not needed in a single process system because the single process is never suspended.单进程运行从一而终，运行到结束，不需要挂起保存状态。

##### 16.说明有没有理由要在一个非空的目录中安装一个文件系统？如果要这样做，如何做？

​	没有理由。在非空目录中安装一个文件系统，会使得原来的目录下内容无法访问，会被替代为被挂载的文件系统的根目录。

​	~~直接在非空目录挂载……~~

​	官方答案上有这样一种说法。由于有可能类似U盘这样的文件系统损坏，管理员会将被挂载文件系统中的关键文件拷贝到挂载点，使得在文件系统损坏的情况下，原来的目录依旧能够访问重要文件。

##### 17.在一个操作系统中系统调用的目的是什么？

​	使用硬件资源完成某些功能。

##### 18.对于下列系统调用，给出引起失败的条件：fork、exec以及unlink。

​	pid_t fork(void)

​	fork need twice memory to spawn a new thread which same with current one

​	fork需要足够的内存执行。如果源进程占用内存很多，那么fork将会因空间不足而失败。

​	int execv(const char * path，char * const argv[])；

​	如果exec指定的路径错误或者目标程序不存在，函数会终止运行。

​	int unlink(const char * pathname);（删除文件的函数）

​	如果目标文件不存在或者进程没有删除权限，都会导致失败。

##### 19.在count=write(fd,buffer,nbytes);调用中，能在count中而不是nbytes中返回值吗？如果能，为什么？

​	类比书上P27页count=read(fd,buffer,nbytes)的例子。这个例子中，count和nbytes的大小一般是相同的，但也有可能count更小。count是实际读出的字节数，nbytes是设定的字节数。有可能文件大小不够，就会导致count小于nbytes的情况。

​	到这里write其实也是一样的。我觉得count依旧是<=nbytes。因为有可能内存不足或者怎么样，实际写入时遇到中断关闭，并不能写入全部的数据。所以回答题目，是可以的，在写入成功的情况下，一般两者是相同的。

​	（还有可能文件描述符出错，比如被意外关闭或者不存在，这种情况下count返回错误代码-1)

##### 20.有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用：lseek(fd,3,SEEK_SET); read(fd,&buffer,4);其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？

​	lseek移动文件指针，0是从文件头开始读。3就是从1开始读。用read读4字节内容到buffer中，即读出1,5,9,2

##### 21.假设一个10MB的文件存在磁盘连续扇区的同一个轨道上（轨道号：50）。磁盘的磁头臂此时位于第100号轨道。要想从磁盘上找回这个文件，需要多长时间？假设磁头臂从一个柱面移动到下一个柱面需要1ms，当文件的开始部分存储在的扇区旋转到磁头下需要5ms，并且读的速率是100MB/s

​	1号轨道即为一个柱面，移动50个轨道，即需要50ms；5ms移动到磁头下，0.1s读取文件，总共耗费155ms

##### 22.块特殊文件和字符特殊文件的基本差别是什么？

​	块特殊文件和字符特殊文件都是I/O设备，只是二者读取文件内容的速度有着显著差异。块特殊文件按块大批量读取，如磁盘的扇区，而字符特殊文件按字符读取，属于低速IO设备，如鼠标、键盘。

​	（块特殊文件各块之间独立，可以被独立的读取或写入；而字符特殊文件不可以）

##### 23.在图1-17的例子中库调用称为read，而系统调用自身称为read。这两者都有相同的名字是正常的吗？如果不是，哪一个更重要？

​	正常。使用系统调用的库函数通常是对系统调用的封装，为了体现功能，就将名称起的和系统调用一样。

​	（官答…… 系统调用一般不含有函数名，当然文档里一般有。系统调用一般就使用若干寄存器内的数据，执行一系列的指令完成操作就好，不需要名称。所以库调用的名字更加重要，因为这个一般是直接写在程序内的。）

##### 24.在分布式系统中，客户机-服务器模式很普遍。这种模式能用在单个计算机的系统中吗？

​	可以。客户机-服务器模式对于单机还是分布式系统来说没有区别，对于进程而言，无非是一个客户进程和一个服务器进程。分布式的情况下二者通过套接字和网络进行通信，单机下二者通过其它进程间通信方式进行通信。

##### 25.对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下？为什么？

​	有必要，尤其是在开发高性能软件的情况下。尽量少的调用使用系统调用的库过程调用，可以有效的减少上下文切换的时间，从而提高程序性能。

##### 26.图1-23说明有一批UNIX的系统调用没有与之相等价的Win32 API。对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？

​	要将UNIX下的系统调用函数用WIN32API进行切换。某些没有对应功能的UNIX系统调用，则只能自己手动写程序进行处理。

##### 27.可移植的操作系统是能从一个系统体系结构到另一个体系结构的移动不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个高度可移植的操作系统时你设计的高级的两层是什么样的。

​	不同的CPU、体系结构具有各自相异的指令集。如果要建立一个完全可移植的操作系统，相当于要在每一个对应的指令体系上用汇编写一个操作系统，工作量极其庞大而且容易出错，几乎是不可行的。如果需要建立高度可移植的操作系统，就可以参考java虚拟机的套路，在不同的底层上用不同的指令集实现一个通用的调用接口，然后在此基础之上，所有的操作系统命令都由这个接口层调用并执行，这样就可以跨平台了。

##### 28.请解释在建立基于微内核的操作系统时策略与机制的分离带来的好处。

​	策略由用户态进程完成，可以在用户态进行进程调用优先级的修改，用户程序能更有效的控制进程运行？（我不会！理解太浅薄了……

​	（策略与机制分离使得微内核可以更小，内核中只使用几个特别初始的进程完成一些必要的功能，复杂的进程在此之上可以进行扩展）

##### 29.下面是单位转换的练习：

###### 	a)一微年是多少秒？

​	micro是10^-6次，一年是365\*24\*3600，所以一微年是31.536s

###### 	b)微米常称为micron。那么gigamicron是多长？

​		micro是10^-6 giga是10^9 ，大概是一千米

###### 	c)1TB存储器中有多少字节？

​		2^40次，~~不想敲计算器了~~，大概是1099,511,627,776bytes

###### 	d)地球的质量是6000 yottagram，换算成kilogram是多少？

​		yotta是10^24次，kilo是10^3 ，所以6000 yottagram 大概是6 * 10^24 kilogram