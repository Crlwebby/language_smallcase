char * modifyString(char * s){
    int length = strlen(s);
    if(s == NULL)
        return NULL;
    if(length == 1){
        if(s[0] == '?')
            s[0] = 'a';
        return s;
    }
    for(int i = 0; i < strlen(s); i++){
        if(s[i] == '?'){
            s[i] = 'a' + i%25;
            if(i == 0){//处理第一位
                if(s[i + 1] == '?')//如果刚开始就是两个连续问号，只要处理第二个就行了，第一个直接过掉
                    continue;
                else{//第一个是问号的情况，与后面一个进行比较，直到不相等
                    while(s[i] == s[i + 1]){
                        s[i] = s[i] + 1;
                        s[i] = s[i] > 122?s[i]-26:s[i];
                    }
                    continue;
                }
            }
            if(i == length - 1){//考虑最后一位，只需要和它前面一位进行比较，如果相等就不断遍历字母表，直到不相等
                while(s[i] == s[i - 1]){
                    s[i] = s[i] + 1;
                    s[i] = s[i] > 122?s[i] - 26:s[i];
                }
                continue;
            }
            while(s[i] == s[i - 1] || s[i] == s[i + 1]){//一样的思路，只是和前面后面两个进行判断
                s[i] = s[i] + 1; 
                s[i] = s[i] > 122?s[i] - 26:s[i];
            }
        }//只对'?’位进行处理，否则可能会误改原字符串
    }
    return s;
}
//第一次写注释，因为没过两分钟，自己就看不懂自己在写什么了……老老实实注释一下
//逻辑又是写的极其复杂，效率似乎还不错？去看看更清楚的思想吧，这一团浆糊的思考……

//对的，我其实想复杂了，s[i]根本不需要考虑是否超过z的问题，因为就只需要根据前后两位进行更改而已，不可能有过多的值的
//只不过是我懒得定义一个常量'a'，于是就要用更加复杂的条件表达式去处理'a'+i逐渐超过'z'的情况……