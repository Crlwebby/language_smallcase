func findMaxConsecutiveOnes(nums []int) int {
	length := len(nums)
	ans := 0
	dp0, dp1 := 0, 0
	for i := 0; i < length; i++ {
		if nums[i] == 1 {
			dp0, dp1 = dp0+1, dp1+1
		} else {
			dp0, dp1 = 0, dp0+1
		}
		ans = max(ans, max(dp0, dp1))
	}
	return ans
}

//DP怎么说，不是很好理解，但是可以尝试做一下解释。
//现在感觉DP有些内容和状态转移很像，无非是如何定义状态比较困难
//这里的状态转移条件只有两个，遇见0或者遇见1。遇见0的时候有可能把它变成1
//于是就有了两个DP数组。前一个保存正常的统计，后一个保留变成1的可能性
//于是就有了if的两个对应执行。如果遇见1，那么两者一致，都往后计数；
//如果遇见0，正常的统计会中断，但是可能变成1的那个，可以继续统计，保留可能性。
//由于为了省空间，只用两个变量，于是每次变更值之后，都有可能是最大值，因此在循环内找结果。