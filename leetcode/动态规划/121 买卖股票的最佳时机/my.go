func maxProfit(prices []int) int {
	res := 0
	min := prices[0]
	len := len(prices)
	for i := 1; i < len; i++ {
		res = max(res, prices[i]-min)
		if min > prices[i] {
			min = prices[i]
		}
	}
	return res
}

//迷迷糊糊做出来的，真的好久不学习，现在脑子跟一团浆糊一样
//简单来说，这题看起来像是动态规划，有动态规划的思想在，但更像是普通的数组题
//保存此前的价格最低的股票值，然后往后遍历，发现如果某刻卖出比现在收益高了，就更新收益

//10.14日再次做题，发现还是不太会，总是会陷入：如果当前是最低点，那么后面的高点和这个最低点的差值不如以前的高点和次低点的差值怎么办？
//问题是，因为一次循环，所以每个低点都会被遍历到。min保有的是当前一个范围内的最低点。如果收益够大，我就可以在某刻卖出；然后往后继续看有没有更大的收益
//这个是比较获得的，不是说找到一个最低点，就直接找最高点之后的值了

//第三遍了23333，感觉理解了。困惑还是一致的，但是解惑有了新的思路。
//怎么说，反正O(n)过来的，res一致用max函数保存着以前的最小值，总归不会漏掉的。后面遇见买入价更低的直接换掉即可，因为即使后面再有高价
//那肯定还是和更低价的差值更大
//好头疼，注释写的很乱，不知道以后看不看得懂了。