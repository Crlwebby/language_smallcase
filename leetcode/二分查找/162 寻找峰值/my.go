func findPeakElement(nums []int) int {
	length := len(nums)
	if length == 1 || nums[0] > nums[1] {
		return 0
	}
	if nums[length-1] > nums[length-2] {
		return length - 1
	}
	i, j := 1, length-2
	ans := 0
	for i <= j {
		ans = (i + j) / 2
		if nums[ans] > nums[ans-1] && nums[ans] > nums[ans+1] {
			return ans
		} else if nums[ans] > nums[ans-1] {
			i = ans + 1
		} else {
			j = ans - 1
		}
	}
	return ans
}

//思路看完一遍就懂了，就是说，数字越大的，越有可能是峰值（比两边相邻的都大）
//那么就进行二分查找；如果当前mid不是峰值，那么继续往更大的一边找（不是峰值的话肯定有更大的一边嘛），这样下去肯定找得到；
//无非是处理两个边界点，0和length-1的位置稍微麻烦一点

//几个月后再刷，发现有点思路上的问题没理解透彻；
//为什么找到一个伪峰值（大于一边），然后继续用二分查找会更快呢？
//比如样例数据 xxxxxxx 2 3 6 9 9 9 9 9 9 9 8
//这里3是中点。按我自己思路来说，从3往右直接一步一步找也很快，但是事实不如人意。那么为什么从3-8这个区间，随机选值按照之前的做法，就一定可以呢？
//这个很像不等式的渐近关系。比如3<6，那么我们可以判断，3的右边一定有峰值；此时在右边找，发现某个点k，如果k < k-1，那么k的左边一定有峰值，和前面的条件叠加，
//就可以知道在3-k之间一定有峰值；如果k > k - 1，那么k的右边一定有峰值，那继续往右好了，此时的条件是前面条件的收缩，也是可以满足的，这样就可以缩小范围，加快查找速度