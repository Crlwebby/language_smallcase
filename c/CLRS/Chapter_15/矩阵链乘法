什么是矩阵链乘法？
就是一连串的若干矩阵相乘，由于矩阵Ai,j * Bj,k 有一个乘法运算次数 即i*j*k，而矩阵乘法满足结合律
不同的运算次序会使得矩阵链乘法的效率大不相同，因此我们想要找到一个运算次序，使得计算代价最小

什么是完全括号化？
完全括号化的矩阵链，要么是由单一矩阵构成的，要么是由两个完全括号化的矩阵构成的。也就是已经决定好运算代价最小的加了括号的矩阵链

求解思路
一：暴力法
    为了说明使用动态规划，我们必须先说服自己，暴力是不行滴！暴力法的思路是怎样的呢？假设求规模为k的矩阵链代价是p(k)
    那么p(1)=1肯定没问题，于是p(n)= p(k)*p(n-k)
    于是，暴力法的P(n) = {1, n=1 || 求和(k=1--k=n)p(k)*p(n-k)}
    据说有一个相似的递归公式产生的序列是卡塔兰数，增长速度为4^n/n^(3/2)，指数肯定是行不通的，指数规模没多少就炸了

二：动态规划
    先来复习下动态规划的四个步骤：
        一：找到最优解的结构特征，即找到最优子结构
        二：递归定义最优解的值（大概相当于递推公式？）
        三：计算最优解的值，有自底向上和带备忘录的自顶向下法
        四：利用保存的信息构造最优解
    
    对于矩阵链乘法而言
    一：最优子结构
        就是对于分割点k，Ai,k和Ai+1,j两条子链的最小代价，这两者的最小代价求出来了，本身的最小代价也就求出来了。至于分割点k在哪？
        那就需要一次循环从i到j进行遍历了
    二：递归定义最优解的值
        假设m[i,j]为Ai-Aj这条矩阵链的最小代价，并且假设对于矩阵Ai，其规模为pi-1*pi 那么m[i,j]的代价为
            m[i,j]=m[i,k]+m[k+1,j]+pi-1*pk*pj
        但分割点k其实是不知道的，因而m[i,j]实际上还要对于所有的i-j找分割点，然后取个min
        即m[i,j]=min{m[i,k]+m[k+1,j]+pi-1*pk*pj},i<=k<j
    三：计算最优解的值
        定义一个n*n矩阵，用于存放任意长度矩阵链的代价,比如[i,j]的代价，i,j都在0-n之间
        可以再定义一个n*n矩阵，用于保存额外信息，即分割点k，以便需要的时候构造最优解
        第一遍两两矩阵相乘，计算代价；第二遍三个矩阵相乘，计算最小代价，以此类推，直到题目要求的长度为n的矩阵链的最小代价
    四：利用保存的信息构造最优解
        定义s[n*n]矩阵，保存两个矩阵之间的最优分割点，然后按下标索引这个矩阵，按中序遍历的方法，就可以从左到右输出每一个分割点的位置